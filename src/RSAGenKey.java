import java.io.*;
import java.math.BigInteger;
import java.util.Random;

public class RSAGenKey {
    private static final int BITLENGTH = 512;
    private static final int MODBITLENGTH = 1024;
    public static void main(String args[]) throws IOException {
        BigInteger firstPrime = BigInteger.ZERO;
        BigInteger secondPrime = BigInteger.ZERO;
        BigInteger modulus = BigInteger.valueOf(0);
        BigInteger pubExpo = BigInteger.valueOf(65537);
        BigInteger privExpo = BigInteger.valueOf(0);
        BigInteger phi_n = BigInteger.valueOf(0);
        Boolean validParams = false;

        if(args.length < 1) {
            System.out.printf("Error, please provide file destination for key generation.\nExiting Program now.\n");
            System.exit(-1);
        }

        String keyFile = args[0];

        /** check for valid data that was generated by BigInteger class. if any conditions fail regenerate **/
        while(!validParams)
        {
            firstPrime = genPrime();
            secondPrime = genPrime();
            modulus = firstPrime.multiply(secondPrime);
            phi_n = (firstPrime.subtract(BigInteger.valueOf(1))).multiply(secondPrime.subtract(BigInteger.valueOf(1)));
            privExpo = pubExpo.modInverse(phi_n);
            validParams = checkParams(firstPrime, secondPrime, modulus, privExpo, pubExpo, phi_n);
        }

        /** Instantiation of RSA object to write modulus, public exponent, and private exponent to file **/
        RSA_IO RSA = new RSA_IO();
        RSA.writeKeys(modulus.toByteArray(), pubExpo.toByteArray(), privExpo.toByteArray(), keyFile);
    }

    /**
     * This method conducts quality checks on RSA prime numbers, public/private exponents and phi_n
     * @param p - Prime integer 1 - first prime generated using genPrime()
     * @param q - Prime integer 2 - second prime generated using genPrime()
     * @param n - p * q
     * @param d - e^-1 mod phi(n)
     * @param e - 65537
     * @param phi_n - (p-1)(q-1)
     * @return boolean value - true if conditions all pass / false if any condition fails
     **/
    private static boolean checkParams(BigInteger p, BigInteger q, BigInteger n, BigInteger d, BigInteger e, BigInteger phi_n){
        if(!(p.isProbablePrime(10))) return false;                      /* if p is not prime return false */
        if(!(q.isProbablePrime(10))) return false;                      /* if q is not prime return false */
        if(!(n.bitLength() <= MODBITLENGTH)) return false;                      /* if n's bitlength is greater than the modulus bit length return false */
        if(p.equals(q)) return false;                                           /* if p == q return false */
        if(!(e.gcd(phi_n)).equals(BigInteger.ONE)) return false;                /* if gcd(e,phi_n) != 1 return false */
        if(!(d.multiply(e).mod(phi_n)).equals(BigInteger.ONE)) return false;    /* if d * e mod phi_n != 1 return false */
        if(!((e.multiply(d)).mod(phi_n)).equals(BigInteger.ONE)) return false;  /* if e* d mod phi_n != 1 return false */
        if((d.bitCount() > n.bitCount()) || ((n.bitCount() - d.bitCount()) > 15)) return false; /* if d's bitcount is > n's bitlength OR
                                                                                                    the difference in bits is > 15 return false (project specs) */
        return true;
    }

    /**
     *  genPrime function generates large prime numbers using the BigInteger class
     *  Utilizes Probable prime = (1 - 1/2^certainty) to calculate the probability that a number is prime
     *
     * @return BigInteger that is most 99.9% prime
     *  **/
    private static BigInteger genPrime(){
        Random rand = new Random();
        double certainty = Math.log(1/0.001)/Math.log(2);
        return new BigInteger(BITLENGTH, (int) certainty, rand);
    }

//    private static void printout() throws IOException {
//        int[] myint = {
//                0x00, 0xb2, 0xf5, 0xfd, 0x3f, 0x9f, 0x09, 0x17, 0x11, 0x2c, 0xe4, 0x2f, 0x8b, 0xf8, 0x7e,
//                0xd6, 0x76, 0xe1, 0x52, 0x58, 0xbe, 0x44, 0x3f, 0x36, 0xde, 0xaf, 0xb0, 0xb6, 0x9b, 0xde,
//                0x24, 0x96, 0xb4, 0x95, 0xea, 0xad, 0x1b, 0x01, 0xca, 0xd8, 0x42, 0x71, 0xb0, 0x14, 0xe9,
//                0x6f, 0x79, 0x38, 0x6c, 0x63, 0x6d, 0x34, 0x85, 0x16, 0xda, 0x74, 0xa6, 0x8a, 0x8c, 0x70,
//                0xfb, 0xa8, 0x82, 0x87, 0x0c, 0x47, 0xb4, 0x21, 0x8d, 0x8f, 0x49, 0x18, 0x6d, 0xdf, 0x72,
//                0x72, 0x7b, 0x9d, 0x80, 0xc2, 0x19, 0x11, 0xc3, 0xe3, 0x37, 0xc6, 0xe4, 0x07, 0xff, 0xb4,
//                0x7c, 0x2f, 0x27, 0x67, 0xb0, 0xd1, 0x64, 0xd8, 0xa1, 0xe9, 0xaf, 0x95, 0xf6, 0x48, 0x1b,
//                0xf8, 0xd9, 0xed, 0xfb, 0x2e, 0x39, 0x04, 0xb2, 0x52, 0x92, 0x68, 0xc4, 0x60, 0x25, 0x6f,
//                0xaf, 0xd0, 0xa6, 0x77, 0xd2, 0x98, 0x98, 0xf1, 0x0b, 0x1d, 0x15, 0x12, 0x8a, 0x69, 0x58,
//                0x39, 0xfc, 0x08, 0xed, 0xd5, 0x84, 0xe8, 0x33, 0x56, 0x15, 0xb1, 0xd1, 0xd7, 0x27, 0x7b,
//                0xe6, 0x5c, 0x53, 0x2d, 0xca, 0x92, 0xdd, 0xc7, 0x05, 0x03, 0x74, 0x86, 0x8b, 0x11, 0x7e,
//                0xa9, 0x15, 0x49, 0x14, 0xef, 0x92, 0x92, 0xb8, 0x44, 0x3f, 0x13, 0x69, 0x6e, 0x4f, 0xad,
//                0x50, 0xde, 0xd6, 0xbd, 0x90, 0xe5, 0xa6, 0xf7, 0xed, 0x33, 0xbe, 0x2e, 0xce, 0x31, 0xc6,
//                0xdd, 0x7a, 0x42, 0x53, 0xee, 0x6c, 0xdc, 0x56, 0x78, 0x7d, 0xdd, 0x1d, 0x5c, 0xd7, 0x76,
//                0x61, 0x40, 0x22, 0xdb, 0x87, 0xd0, 0x3b, 0xb2, 0x2f, 0x23, 0x28, 0x5b, 0x5a, 0x31, 0x67,
//                0xaf, 0x8d, 0xac, 0xab, 0xbe, 0xa4, 0x00, 0x04, 0x47, 0x13, 0x37, 0xd3, 0x78, 0x1e, 0x8c,
//                0x5c, 0xca, 0x0e, 0xa5, 0xe2, 0x77, 0x99, 0xb5, 0x10, 0xe4, 0xef, 0x93, 0x8c, 0x61, 0xca,
//                0xa6, 0x0d};
//        File myFile = new File("C:\\Users\\Chris\\Desktop\\RSA_TEST\\data\\key.txt");
//        File datFile = new File("C:\\Users\\Chris\\Desktop\\RSA_TEST\\data\\keys.dat");
//
//        FileWriter fw = new FileWriter(myFile);
//        DataOutputStream outfile = new DataOutputStream(new FileOutputStream(datFile));
//        for(int i = 0; i < myint.length;i++)
//        {
//            outfile.writeByte(myint[i]);
//        }
//        outfile.close();
//
//        fw.write(String.format("Public Key Size: (%d) bytes",myint.length));
//        for(int i = 0; i < myint.length;i++){
////            if(i == 0)
////                fw.write("\t");
//            if(i % 16 == 0)
//                fw.write("\n\t");
//            fw.write(String.format("0x%02X", myint[i]));
//            if(i != myint.length)
//                fw.write(":");
//        }
//        fw.close();
//    }
//
//    private static void readfromfile() throws IOException{
//        File myFile = new File ("C:\\Users\\Chris\\Desktop\\RSA_Test\\data\\key.txt");
//        Scanner kb = new Scanner(myFile);
//        String input = kb.nextLine();
//        int startIndex = input.indexOf('(');
//        int endIndex = input.indexOf(')',startIndex);
//        int size = Integer.parseInt(input.substring(startIndex+1,endIndex));
//
//
//    }
    //        userInput = userInput.substring(userInput.length() - 3,userInput.length());
//        if(datExtension.compareToIgnoreCase(userInput) != 0){
//            System.out.println("Error, key file needs to have \".dat\" extension.\nExiting Program now.");
//            System.exit(-1);
//        }



//    String plaintext = "Hello world\nThis is Chris";
//    byte[] myByteArray = plaintext.getBytes();                  /* Convert string to byte array */
//    BigInteger pBytearray = new BigInteger(myByteArray);        /* convert byte array to BigInteger (stored as 2's compliment) */
//    BigInteger encrypted = pBytearray.modPow(pubExpo,modulus);  /* Encrypt BigInt using pubExpo (e) and modulus N */
//    byte[] encryptedBytes = encrypted.toByteArray();            /* store cipher text in byte array */
//    BigInteger decrypted = encrypted.modPow(privExpo,modulus);  /* DECRYPT using ciphertext, private exponent (d) and modulus n */
//    byte[] decryptedBytes = decrypted.toByteArray();            /* store in byte array (2's compliment representation) */
//        if(Arrays.equals(decryptedBytes,myByteArray)) {              /* check decrypted message and original */
//        String s = new String(decryptedBytes);
//        System.out.printf("Decrypted String:\n\"%s\"",s);
//    }
//
// FileOutputStream fos = new FileOutputStream("C:\\Users\\Chris\\Desktop\\RSA_TEST\\data\\testing.dat");
//        fos.write(mod.length);
//        fos.write(e.length);
//        fos.write(d.length);
//        fos.write(mod);
//        fos.write(e);
//        fos.write(d);
//        fos.close();
//
//        FileInputStream FIS = new FileInputStream("C:\\Users\\Chris\\Desktop\\RSA_TEST\\data\\address.txt");
//        byte[] inString = FIS.readAllBytes();
//        BigInteger input = new BigInteger(inString);
//        String s = new String(inString);
//        FIS.close();
//
//        BigInteger cipherText = input.modPow(pubExpo,modulus);
//        FileOutputStream foss = new FileOutputStream("C:\\Users\\Chris\\Desktop\\RSA_TEST\\data\\address.enc");
//        foss.write(cipherText.toByteArray());
//        foss.close();
//
//        FileInputStream FISS = new FileInputStream("C:\\Users\\Chris\\Desktop\\RSA_TEST\\data\\address.enc");
//        BigInteger cipher = new BigInteger(FISS.readAllBytes());
//        cipher = cipher.modPow(privExpo,modulus);
//        String ss = new String(cipher.toByteArray());
//        FISS.close();
//        FileOutputStream FOSSS = new FileOutputStream("C:\\Users\\Chris\\Desktop\\RSA_TEST\\data\\d_address.txt");
//        FOSSS.write(cipher.toByteArray());
//        FOSSS.close();

}
